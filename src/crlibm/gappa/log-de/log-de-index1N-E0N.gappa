# Usage: This files builds an error computation for all possible
#exponent values, but for one index value only. To get a complete
#proof you need to run it through gappa for all the possible values of
#the constants. However, it doesn't work for the index value 0: use
#file log-de-logir0-E0 instead

# Running the ../maple/log-de.mpl Maple script
# should create the required sed files and give the command to run.
# Example   sed  -f ../maple/TEMPLOG/polynomials.sed  -f ../maple/TEMPLOG/log-de_1.sed ../gappa/log-de.gappa | ~/gappa/src/gappa 


# NOTATION CONVENTION 
# Variables that will be replaced with Maple-computed constants begin with an underscore
# Variables that correspond to double-precision variables in the code begin with a small letter
# Other variables begin with a capital letter.

#  Remove the following line when editing this file, to get back the warnings (all the current ones are harmless)
#@ -Wno-hint-difference -Wno-null-denominator
# Remark: asking for  warnings resuires at least 512MB of memory

#This is to prevent another warning which might let you think Gappa failed when it eventually succeeds. 
#@ -Wno-dichotomy-failure

@IEEEdouble = float<ieee_64,ne>;
@IEEEext = float<x86_80,ne>;

# This is to tell Gappa that E is an integer.
E=int<ne>(dummyE);

# polynomial coefficients, computed by Maple
#c1 = IEEEext(_c1); # Since c1=1, it does not appear in the C code anymode
c2 = IEEEext(_c2);
c3 = IEEEext(_c3);
c4 = IEEEext(_c4);
c5 = IEEEext(_c5);
c6 = IEEEext(_c6);
c7 = IEEEext(_c7);

# other constants, also from Maple
log2h = IEEEext(_log2h);
log2l  = IEEEext(_log2l);

#table values
r     = IEEEext(_rval);
logirh = IEEEext(_logirh);
logirl = IEEEext(_logirl);


# Transcription of the code, NOT using FMA
z2   IEEEext= z*z;    
p67  IEEEext= c6 + z*c7;       
p45  IEEEext= c4 + z*c5;      
p23  IEEEext= c2 + z*c3;    
p01  IEEEext= logirh + z;
z4   IEEEext= z2*z2;  
p47  IEEEext= p45 + z2*p67;    
p03  IEEEext= p01 + z2*p23; 
p07  IEEEext= p03 + z4*p47;
logz IEEEext= p07 + E*log2h;

#---------- What this code is supposed to approximate
# Exact mathematical definition of the log
Mlogz = Log1pz + Logir + E*Mlog2;

#############   Now come auxiliary definitions
Log2hl = log2h + log2l;
Logirhl = logirh + logirl;

# Give the polynomial in Estrin form (no need to transcribe the intermediate steps)
# Since the argument reduction is exact, Mz = z.
Mz2 = z*z;
Mz4 = Mz2*Mz2;
P07  =  ( (logirh+z) + Mz2*(c2+z*c3) )     + Mz4*( (c4+z*c5) + Mz2*(c6+z*c7)  ); 

Alogz = P07 + E*Mlog2;

PolyLog1pz = z + Mz2*(c2+z*c3) + Mz4*( (c4+z*c5) + Mz2*(c6+z*c7)  );

epsilon = (logz - Mlogz)/Mlogz;


{
(
|E| in [1,1024]
/\  |z| in [1b-200, _zabsmax] 
/\  Log2hl - Mlog2    in [-1b-129, 1b-129] 
/\  Logirhl - Logir in [-1b-129, 1b-129]  
/\  (PolyLog1pz - Log1pz) in [-_deltaApproxQuick, _deltaApproxQuick]
->
epsilon in [-1b-63, 1b-63]
)

/\

(
E in [0,0]
/\    z in [-_zabsmax, _zabsmax] 
/\  Log2hl - Mlog2    in [-1b-129, 1b-129] 
/\  Logirhl - Logir in [-1b-129, 1b-129]  
/\  (PolyLog1pz - Log1pz) in [-_deltaApproxQuick, _deltaApproxQuick]
->
epsilon in [-1b-63, 1b-63]
)

}

logz ~ Alogz;
Alogz ~ Mlogz;


# Trivialities which cannot be expressed using ~
logirh - Logir ->  (logirh +logirl -Logir) - logirl;
log2h-Mlog2  -> ((log2h + log2l) - Mlog2) - log2l;
Mlog2  -> (log2h + log2l) - ((log2h + log2l) - Mlog2);
Logir -> logirh + ((logirl - (logirh +logirl -Logir)));
Mlogz   -> Alogz - (Alogz-Mlogz);

Alogz - Mlogz -> (logirh-Logir) + (PolyLog1pz  - Log1pz);

epsilon $ E;
epsilon $ z;
